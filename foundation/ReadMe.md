# Foundation

Foundation is the baseline of the Caelestis project, and is where common code that can be used
by all plugins can be found. The intention of this is to improve some of the pains of DLL-ificiation,
by providing a stable ABI of functionality and objects that all plugins can use and exchange between
each other. 

This will probably eventually be further tied to the concept of "Capstone", what I plan to use
as the final layer binding all of the plugins together and providing some important frameworks
and functionality for doing so (as part of building a final application).

All said, the point is to allow for a safe and stable ABI for plugins still - but to make sure we're
not forcing ourselves to pointlessly deal with a really painful C-style ABI (compromising dev time further,
and potentially at the cost of perf too). Adding to this will probably happen frequently during the
beginning of the project but that's okay while I get it up and running and built out. Fun developing
this project is just as important to me as making it good!

## The Plugin Manager

One could see this as the heart of any application or system using Caelestis - but this would be a rather dumb heart, to be quite honest. The Plugin manager is a very primitive system when one gets down to it, as it really isn't designed to know anything about the plugins it loads. It provides a few important includes and structures that plugins use, however. A couple quick points:

- Plugins are loaded by calling the exported (through shared library / DLL) `GetPluginAPI()` function with a unique ID. Plugins define this API ID in their plugin header, which is the only header one should usually need to include in order to use a plugin. These IDs have been thus far generated by just running a fnv_32 hash on the names of the plugins

- Plugins are expected to provide at least two APIs: the `Plugin_API` (more shortly), and their unique API. Further APIs can be supported by plugins, however, in order to expose more functionality, to allow for more composed behavior, or to provide things like unit tests through a single structure of testable functions.

- `CoreAPIs.hpp` may define further APIs, but at the moment defines the base `Plugin_API` struct of function pointers that all plugins are expected to fill out. This API is loaded by calling `GetPluginAPI()` on a loaded DLL with `0` as the plugin ID. Ultimately, only `PluginName`, `PluginID`, `Load`, and `Unload` *have* to be provided.

- The passed `GetEngineAPI_Fn` to `Load` can be used by plugins to retrieve the APIs of plugins they depend on. As an example, the `resource_context` depends on the `renderer_context`, and it expects to find it loaded before it is able to function. 

- `LogicalUpdate` should be called at least once per frame on all plugins, as this allows them to process important internal update functions (e.g in `renderer_context` this calls `glfwPollEvents`, dispatching received signals or noting a swapchain event)

- `TimeDependentUpdate` can then be used for processing time-dependent update functionality, such as physics or audio updates. It's currently not heavily used.

Platform-dependent implementations of the plugin manager are kept in the `impl` subdirectory of `src`.

Retrieving the plugin manager is simple - it's designed to be a singleton class, at the moment:

```cpp
PluginManager& manager = PluginManager::GetPluginManager();
manager.LoadPlugin("renderer_context.dll");
Plugin_API* renderer_context_core_api = 
    reinterpret_cast<Plugin_API*>(manager.RetrieveBaseAPI(RENDERER_CONTEXT_API_ID));
renderer_context_core_api->LogicalUpdate();
// etc
```

Lots still to do: like implementing hot-reloading in full, making PDB fixing more robust, not having to specify `.dll`/`.so`/`.dylib`, and a few other QOL improvements. As mentioned elsewhere: still early in development here!